Start compound.Rd
\name{\%<>\%}
\alias{\%<>\%}
\title{Assigment pipe}
\usage{
lhs \%<>\% rhs
}
\arguments{
\item{lhs}{An object which serves both as the initial value and as target.}

\item{rhs}{A function call using the magrittr semantics.}
}
\value{
The result of calling \code{rhs(lhs)}.
}
\description{
See \code{magrittr::\link[magrittr:pipe]{\%<>\%}} for details.
}
\keyword{internal}
End compound.Rd

Start parse_metadata_line.Rd
\name{parse_metadata_line}
\alias{parse_metadata_line}
\title{Parse a Metadata Line from a SeaSonde APM File}
\usage{
parse_metadata_line(line)
}
\arguments{
\item{line}{The line of text to parse.}
}
\value{
Returns a list containing the attribute name and its value.
}
\description{
This function takes a single line from a SeaSonde APM file and parses it into
a named attribute and its corresponding value.
}
End parse_metadata_line.Rd

Start pipe.Rd
\name{\%>\%}
\alias{\%>\%}
\title{Pipe operator}
\usage{
lhs \%>\% rhs
}
\arguments{
\item{lhs}{A value or the magrittr placeholder.}

\item{rhs}{A function call using the magrittr semantics.}
}
\value{
The result of calling \code{rhs(lhs)}.
}
\description{
See \code{magrittr::\link[magrittr:pipe]{\%>\%}} for details.
}
\keyword{internal}
End pipe.Rd

Start process_version_header.Rd
\name{process_version_header}
\alias{process_version_header}
\title{Process a Specific Version of the SeaSonde File Header}
\usage{
process_version_header(
  pool,
  version,
  specs,
  connection,
  endian = "big",
  prev_data = NULL
)
}
\arguments{
\item{pool}{List. An accumulating list of processed headers from prior versions.}

\item{version}{Integer. The specific version of the header to be processed. E.g., for version 3,
the function \code{seasonder_readSeaSondeCSFileHeaderV3} should be present.}

\item{specs}{List. Header specifications for each version. Each entry should correspond to
a version number and contain the required information to process that version's header.}

\item{connection}{Connection object. The file connection pointing to the SeaSonde file.}

\item{endian}{Character string. Specifies the byte order for reading data. Can be "big" (default)
or "little". Use the appropriate value depending on the system architecture and the
file's source.}
}
\value{
List. A combination of the initial \code{pool} and the processed header for the given \code{version}.
Fields in the current header will overwrite or append to the pool as described above.
}
\description{
This function processes a specified version of the SeaSonde file header. It identifies the
appropriate header function for the given version, processes the header, and then updates
the accumulating pool of header data. Specifically:
}
\details{
\enumerate{
\item For fields in the current header that overlap with the accumulated pool, the
current header's values overwrite those in the pool.
\item Fields that are unique to the current header are appended to the pool.
}
}
\section{Assumptions}{

This function assumes that the desired version-specific \verb{seasonder_readSeaSondeCSFileHeaderV*}
functions are available in the global environment.
}

End process_version_header.Rd

Start qc_check_range.Rd
\name{qc_check_range}
\alias{qc_check_range}
\title{Quality Control - Check Range and Type}
\usage{
qc_check_range(field_value, min, max, expected_type = NULL)
}
\arguments{
\item{field_value}{The value to be checked.}

\item{min}{Minimum allowable value for field_value.}

\item{max}{Maximum allowable value for field_value.}

\item{expected_type}{(optional) The expected type of the field_value. Default is NULL.}
}
\value{
The original field_value if it's within range and matches the expected_type; otherwise, an error is raised.
}
\description{
This function verifies if a given value lies within a specified range
and matches the expected type, if provided.
}
\examples{
qc_check_range(15L, 1, 32, "integer") # Returns 15L
qc_check_range(40L, 1, 32, "integer") # Raises error
qc_check_range("15", 1, 32, "integer") # Raises error
qc_check_range(15L, 1, 32) # Returns 15L
}
End qc_check_range.Rd

Start qc_check_type.Rd
\name{qc_check_type}
\alias{qc_check_type}
\title{Quality Control - Check Type}
\usage{
qc_check_type(field_value, expected_type)
}
\arguments{
\item{field_value}{The value whose type needs to be checked.}

\item{expected_type}{The expected type of the field_value.}
}
\value{
The original field_value if it matches the expected_type; otherwise, an error is raised.
}
\description{
This function verifies if a given value is of the expected type.
}
\examples{
qc_check_type(100L, "integer") # Returns 100L
qc_check_type("100", "integer") # Raises error
}
End qc_check_type.Rd

Start read_and_qc_field.Rd
\name{read_and_qc_field}
\alias{read_and_qc_field}
\title{Read and Quality Control a Single Field}
\usage{
read_and_qc_field(field_spec, connection, endian = "big")
}
\arguments{
\item{field_spec}{A list containing the specifications for the field to read.
It should contain:
\itemize{
\item \code{type}: the type of data to read, passed to \code{seasonder_readCSField}.
\item \code{qc_fun}: the name of a quality control function. As detailed in \code{seasonder_readSeaSondeCSFileBlock},
this function should be present in the shared environment \code{seasonder_the} and must accept
\code{field_value} as its first argument, followed by any other arguments specified in \code{qc_params}.
\item \code{qc_params}: a list of additional parameters to pass to the quality control function. See
\code{seasonder_readSeaSondeCSFileBlock} for detailed expectations of the QC function behavior.
}}

\item{connection}{A connection to the binary file.}

\item{endian}{A character string indicating the byte order. Options are "big" and "little" (default is "big").}
}
\value{
The value of the field after quality control. Can be the original value, a transformed value,
or NULL if the value fails quality control. The exact behavior of the quality control function, including
the handling of NULL values, is detailed in \code{seasonder_readSeaSondeCSFileBlock}.
}
\description{
This auxiliary function reads a field from a binary file using a provided specification and
applies a quality control function on the retrieved data. The expectations and functioning of the
quality control functions are described in detail in the documentation for \code{seasonder_readSeaSondeCSFileBlock}.
}
\section{Error Management}{


The \code{read_and_qc_field} function uses the \code{rlang} package to manage errors and conditions
in a structured way. This documentation section details the classes of errors/conditions
generated, the cases considered, and the restart options provided.

\strong {Error/Condition Classes}:
\itemize{
\item \code{seasonder_cs_field_skipped}: Condition that indicates a CSField was skipped during reading.
\item \code{seasonder_cs_field_qc_fun_rerun}: Condition that indicates a rerun of the quality control function was triggered.
\item \code{seasonder_cs_field_qc_fun_not_defined_error}: Error raised when the quality control function specified is not found in the shared environment \code{seasonder_the}.
\item \code{seasonder_cs_field_qc_fun_error}: Error raised when an issue occurs while applying the quality control function.
}

\strong {Error/Condition Cases}:
\itemize{
\item If a CSField is skipped during reading, the condition \code{seasonder_cs_field_skipped} is used to skip QC and then is re-signaled.
\item If an alternate QC is rerun using the \code{seasonder_rerun_qc_with_fun} restart, the condition \code{seasonder_cs_field_qc_fun_rerun} is signaled.
\item If the quality control function specified is not found in the shared environment \code{seasonder_the}, the error \code{seasonder_cs_field_qc_fun_not_defined_error} is raised.
\item If there's an issue applying the quality control function, the error \code{seasonder_cs_field_qc_fun_error} is raised.
}

\strong {Restart Options}:
The function provides structured mechanisms to recover from errors/conditions during its execution using \code{withRestarts}. The following restart options are available:

\itemize{
\item \code{seasonder_rerun_qc_with_fun}: Allows for rerunning QC with an alternate function.
\itemize{
\item \strong{Usage}: In a custom condition handler, you can call \code{seasonder_rerun_qc_with_fun(cond, alternateQCfunction)} to trigger this restart and run an alternate QC using \code{alternateQCfunction}. \code{alternateQCfunction} will be used as follows alternateQCfunction(x) being x the value. No extra parameters are passed.
\item \strong{Effect}: If invoked, the function logs an info message detailing the reason of the rerun, and then returns the value returned by \code{alternateQCfunction}.
}
}

It's also important to note that within \code{read_and_qc_field}, the function \code{seasonder_readCSField} is used. This function has its own error management and restart options, which are detailed in its documentation.
}

End read_and_qc_field.Rd

Start read_matrix_row.Rd
\name{read_matrix_row}
\alias{read_matrix_row}
\title{Read a Row from a Matrix Represented as Text Lines}
\usage{
read_matrix_row(lines, start, number_of_lines_to_read)
}
\arguments{
\item{lines}{The array of lines, each representing part of the row.}

\item{start}{The start index of the lines to read from.}

\item{number_of_lines_to_read}{The number of lines to read to form the row.}
}
\value{
Returns a numeric vector containing the row values.
}
\description{
This function reads a row of numbers from a matrix, which is represented
as an array of text lines. It's used to facilitate reading data from
SeaSonde APM files.
}
End read_matrix_row.Rd

Start readV6BlockData.Rd
\name{readV6BlockData}
\alias{readV6BlockData}
\title{Read Version 6 Block Data}
\usage{
readV6BlockData(
  specs,
  connection,
  endian = "big",
  prev_data = NULL,
  remaining_loops = NULL
)
}
\arguments{
\item{specs}{A list. Specifications detailing the structure and content of the data blocks.
Contains variable names, types, quality check functions, and other related attributes.
For repeated blocks, a 'repeat' key is added which details the loop structure and
nested specifications.}

\item{connection}{A connection object. Represents the connection to the data source. It's passed
to the lower-level reading function.}

\item{endian}{A character string. Specifies the byte order to be used. Default is "big".
Passed to the lower-level reading function.}

\item{prev_data}{A list. Previous data or metadata that might be required to inform the reading
process, such as loop lengths for repeated blocks. Default is NULL.}

\item{remaining_loops}{A character vector. Details the remaining loops to be processed for
repeated blocks. Internally used for recursive processing. Default is NULL.
If provided, it should always be in sync with the repeat specifications.}
}
\value{
A list. Contains the read and processed data based on the provided specifications.
Regular variables are returned at the top level. Repeated blocks are nested lists with
'loop' and 'data' keys detailing the loop variable and corresponding data.
}
\description{
This function reads and processes regular and repeated blocks of data
based on provided specifications. Regular blocks are read directly, while
repeated blocks are processed recursively based on a set of loops provided
in the specifications.
}
End readV6BlockData.Rd

Start seasonder_archive_expression_log.Rd
\name{seasonder_archive_expression_log}
\alias{seasonder_archive_expression_log}
\title{seasonder_archive_expression_log function}
\usage{
seasonder_archive_expression_log(expr, ...)
}
\arguments{
\item{expr}{An expression to be evaluated. This expression should signal a 'seasonder_log' condition using \code{seasonder_log} function when needed.}

\item{...}{Additional parameters passed to \code{seasonder_log_archiver} function.}
}
\value{
The result of evaluating the input expression \code{expr}.
}
\description{
This function wraps the provided expression \code{expr} in a tryCatch block and archives the log information
whenever a 'seasonder_log' condition is signaled within the evaluated expression. The log message is archived
by calling \code{seasonder_log_archiver} with the signaled condition \code{cond} and any additional parameters.
}
End seasonder_archive_expression_log.Rd

Start seasonder_areLogsEnabled.Rd
\name{seasonder_areLogsEnabled}
\alias{seasonder_areLogsEnabled}
\title{Check if log recording is enabled in SeaSondeR}
\usage{
seasonder_areLogsEnabled()
}
\value{
Logical indicating whether logs are enabled or disabled.
}
\description{
This function checks whether log recording is currently enabled
in the SeaSondeR package.
}
\examples{
seasonder_areLogsEnabled()
}
End seasonder_areLogsEnabled.Rd

Start seasonder_areMessagesEnabled.Rd
\name{seasonder_areMessagesEnabled}
\alias{seasonder_areMessagesEnabled}
\title{Check if message logging is enabled in SeaSondeR}
\usage{
seasonder_areMessagesEnabled()
}
\value{
Logical indicating whether messages are enabled or disabled.
}
\description{
This function checks whether message logging is currently enabled
in the SeaSondeR package.
}
\examples{
seasonder_areMessagesEnabled()
}
End seasonder_areMessagesEnabled.Rd

Start seasonder_createSeaSondeAPM.Rd
\name{seasonder_createSeaSondeAPM}
\alias{seasonder_createSeaSondeAPM}
\title{Create a SeaSondeAPM Object}
\usage{
seasonder_createSeaSondeAPM(
  calibration_matrix = matrix(complex(real = NA_real_, imaginary = NA_real_), nrow = 2,
    ncol = 0),
  ...
)
}
\arguments{
\item{calibration_matrix}{A 2 x b complex matrix, where b is the number of bearings for calibration.}

\item{...}{Additional named attributes that will be passed to \code{\link{seasonder_initializeAttributesSeaSondeAPM}}.}
}
\value{
A SeaSondeAPM object containing a complex matrix with class attribute 'SeaSondeAPM' and
additional attributes for metadata. Row names are set "A13" and "A23" and column names are set to be the values in BEAR.
}
\description{
This function creates a SeaSondeAPM object to store antenna pattern calibration data.
}
\details{
The function performs the following operations:
\enumerate{
\item Validates the \code{calibration_matrix} with code{\link{seasonder_validateCalibrationMatrixSeaSondeAPM}}.
\item Initializes all other attributes either with default or user-provided values.
\item Merges the initialized attributes into \code{calibration_matrix}.
\item Sets the object's class to 'SeaSondeAPM'.
}

For more details on the attributes, see \code{\link{seasonder_initializeAttributesSeaSondeAPM}}.
}
\examples{
cal_matrix <- matrix(complex(real = c(1, 2), imaginary = c(3, 4)), nrow = 2)
apm <- seasonder_createSeaSondeAPM(cal_matrix)

apm <- seasonder_createSeaSondeAPM(cal_matrix,Creator="Me")
print(attr(apm,"Creator"))
# [1] "Me"

}
\seealso{
\code{\link{seasonder_validateCalibrationMatrixSeaSondeAPM}},
\code{\link{seasonder_initializeAttributesSeaSondeAPM}}
}
End seasonder_createSeaSondeAPM.Rd

Start seasonder_disableLogs.Rd
\name{seasonder_disableLogs}
\alias{seasonder_disableLogs}
\title{Disable log recording in SeaSondeR}
\usage{
seasonder_disableLogs()
}
\description{
This function disables log recording in the SeaSondeR package.
Once disabled, various SeaSondeR functions will no longer output logs.
}
\examples{
seasonder_disableLogs()
}
End seasonder_disableLogs.Rd

Start seasonder_disableMessages.Rd
\name{seasonder_disableMessages}
\alias{seasonder_disableMessages}
\title{Disable message logging in SeaSondeR}
\usage{
seasonder_disableMessages()
}
\description{
This function disables message logging in the SeaSondeR package.
Once disabled, various SeaSondeR functions will no longer output
informational messages.
}
\examples{
seasonder_disableMessages()
}
End seasonder_disableMessages.Rd

Start seasonder_enableLogs.Rd
\name{seasonder_enableLogs}
\alias{seasonder_enableLogs}
\title{Enable log recording in SeaSondeR}
\usage{
seasonder_enableLogs()
}
\description{
This function enables log recording in the SeaSondeR package.
Once enabled, various SeaSondeR functions will output logs.
}
\examples{
seasonder_enableLogs()
}
End seasonder_enableLogs.Rd

Start seasonder_enableMessages.Rd
\name{seasonder_enableMessages}
\alias{seasonder_enableMessages}
\title{Enable message logging in SeaSondeR}
\usage{
seasonder_enableMessages()
}
\description{
This function enables message logging in the SeaSondeR package.
Once enabled, various SeaSondeR functions will output informational
messages.
}
\examples{
seasonder_enableMessages()
}
End seasonder_enableMessages.Rd

Start seasonder_initializeAttributesSeaSondeAPM.Rd
\name{seasonder_initializeAttributesSeaSondeAPM}
\alias{seasonder_initializeAttributesSeaSondeAPM}
\title{Initialize Attributes for a SeaSondeAPM Object}
\usage{
seasonder_initializeAttributesSeaSondeAPM(calibration_matrix, ...)
}
\arguments{
\item{calibration_matrix}{A 2 x b complex matrix, where b is the number of bearings for calibration.}

\item{...}{Additional named attributes that may override the defaults.}
}
\value{
A list containing initialized attributes for a SeaSondeAPM object.
}
\description{
This function initializes attributes for a SeaSondeAPM object, including metadata and properties.
}
\details{
The function initializes the following attributes:
\itemize{
\item \code{quality_matrix}: A 2 x b complex matrix for quality data, where b is the number of bearings.
\item \code{BEAR}: A numeric vector for bearings (degrees).
\item \code{Type}: Character string for antenna pattern type.
\item \code{Creator}: Object creator name. Default is an empty character vector.
\item \code{SiteName}: Site name (not the same as SiteCode). Default is an empty character vector.
\item \code{SiteOrigin}: Numeric vector with two elements representing the Station GPS location. Default is \code{c(0,0)}.
\item \code{FileName}: Default is an empty character vector.
\item \code{CreateTimeStamp}: APM file creation time. Default is current system date and time.
\item \code{ProcessingSteps}: Processing steps applied to this object. Default is an empty character vector.
\item \code{AmplitudeFactors}: Numeric vector with two elements for the amplitude factors. Default is \code{c(0,0)}.
\item \code{AntennaBearing}: Default is an empty numeric vector.
\item \code{StationCode}: 4-character station code. Default is an empty character vector.
\item \code{BearingResolution}: In degrees. Default is an empty numeric vector.
\item \code{Smoothing}: Numeric vector indicating smoothing applied to the antenna pattern. Default is an empty numeric vector.
\item \code{CommentLine}: Metadata lines in the data file not matching any other attribute. Default is an empty character vector.
\item \code{FileID}: File's UUID. Default is an empty character vector.
\item \code{PhaseCorrections}: Numeric vector with two elements for phase corrections. Default is \code{c(0,0)}.
}

Each attribute has a corresponding setter and getter function, following the naming pattern \code{seasonder_set/get_SeaSondeAPM_*}, where * is the name of the attribute. For example, to set the 'Type' attribute, you would use \code{seasonder_set_SeaSondeAPM_Type(seasonde_apm_obj,new_value)}. To get the same, you would use \code{seasonder_get_SeaSondeAPM_Type(seasonde_apm_obj,new_value)}.

Please see \code{\link{seasonder_validateAttributesSeaSondeAPM}} for details in attributes validation.
}
\examples{
# Create a calibration_matrix
cal_matrix <- matrix(complex(real = c(1, 2), imaginary = c(3, 4)), nrow = 2, ncol = 2)

# Initialize attributes with default settings
attr_list <- seasonder_initializeAttributesSeaSondeAPM(calibration_matrix = cal_matrix)
str(attr_list)

# Initialize attributes with custom 'Type'
attr_list_custom <- seasonder_initializeAttributesSeaSondeAPM(calibration_matrix = cal_matrix,
Type = "Custom Pattern")
str(attr_list_custom)

}
\seealso{
\code{\link{seasonder_createSeaSondeAPM}},
\code{\link{seasonder_validateAttributesSeaSondeAPM}}
}
End seasonder_initializeAttributesSeaSondeAPM.Rd

Start seasonder_log_archiver.Rd
\name{seasonder_log_archiver}
\alias{seasonder_log_archiver}
\title{seasonder_log_archiver function}
\usage{
seasonder_log_archiver(
  object,
  log_path = tempfile(),
  log_info_path = log_path,
  log_error_path = log_info_path,
  log_fatal_path = log_error_path
)
}
\arguments{
\item{object}{A list object that contains a 'level' and 'message' elements indicating the level and the message of the log respectively.}

\item{log_path}{A character string indicating the default path where the logs will be stored. Default is a temporary file.}

\item{log_info_path}{A character string indicating the path where the 'info' level logs will be stored. Default is 'log_path'.}

\item{log_error_path}{A character string indicating the path where the 'error' level logs will be stored. Default is 'log_info_path'.}

\item{log_fatal_path}{A character string indicating the path where the 'fatal' level logs will be stored. Default is 'log_error_path'.}
}
\value{
the log object
}
\description{
This function writes the logged message to a specific path based on the level of the log.
}
\examples{
log <- list(level = "info", message = "This is an info message")
seasonder_log_archiver(log)
log <- list(level = "error", message = "This is an error message")
seasonder_log_archiver(log)
log <- list(level = "fatal", message = "This is a fatal message")
seasonder_log_archiver(log)
}
End seasonder_log_archiver.Rd

Start seasonder_log.Rd
\name{seasonder_log}
\alias{seasonder_log}
\title{seasonder_log function}
\usage{
seasonder_log(message, level = c("info", "error", "fatal"))
}
\arguments{
\item{message}{A character string indicating the message to be logged.}

\item{level}{A character string that defines the level of the log. It can be "info", "error", or "fatal". Default is "info".}
}
\description{
This function creates a logging message and signals a seasonder_log condition.
}
\examples{
seasonder_log("This is an info message")
seasonder_log("This is an error message", "error")
seasonder_log("This is a fatal message", "fatal")
}
End seasonder_log.Rd

Start seasonder_logAndAbort.Rd
\name{seasonder_logAndAbort}
\alias{seasonder_logAndAbort}
\title{Log and Abort Message in SeaSondeR}
\usage{
seasonder_logAndAbort(msg, calling_function = NULL, ...)
}
\arguments{
\item{msg}{A character string indicating the message}

\item{calling_function}{function where the condition happened. If NULL (default), the code tries to determine which one was.}

\item{...}{passed to \code{rlang::abort}}
}
\value{
An invisible NULL. The function modifies the shared environment \code{seasonder_the} in place if logs are enabled.
}
\description{
This function logs a message to the SeaSondeR logging system and also aborts the execution.
It prefixes the abort message with the name of the calling function.
}
\examples{
\dontrun{
my_function <- function() {
  seasonder_logAndAbort("This is a message")
}
my_function()
}

}
End seasonder_logAndAbort.Rd

Start seasonder_logAndMessage.Rd
\name{seasonder_logAndMessage}
\alias{seasonder_logAndMessage}
\title{Log and Inform Message in SeaSondeR}
\usage{
seasonder_logAndMessage(msg, log_level = "info", calling_function = NULL, ...)
}
\arguments{
\item{msg}{A character string indicating the message to be logged and informed.}

\item{log_level}{A character string indicating the level of the log ("info", "error", "fatal"). Default is "info".}

\item{calling_function}{function where the condition happened. If NULL (default), the code tries to determine which one was.}

\item{...}{passed to \code{rlang::inform} (log_level="info") or \code{rlang::warn} (log_level="error").}
}
\value{
An invisible NULL. The function modifies the shared environment \code{seasonder_the} in place if logs are enabled, and informs the message if messages are enabled.
}
\description{
This function logs a message to the SeaSondeR logging system and also informs the message to the console.
It prefixes the message with the name of the calling function.
}
\examples{
\dontrun{
my_function <- function() {
  seasonder_logAndMessage("This is a message", "info")
}
my_function()
}

}
End seasonder_logAndMessage.Rd

Start seasonder_raw_to_int.Rd
\name{seasonder_raw_to_int}
\alias{seasonder_raw_to_int}
\title{Convert a Raw Vector to a 64-bit Integer}
\usage{
seasonder_raw_to_int(r, signed = F)
}
\arguments{
\item{r}{A raw vector to be converted.}

\item{signed}{Logical, indicating whether the conversion should consider the value as signed (default is FALSE for unsigned).}
}
\value{
A 64-bit integer representation of the raw vector.
}
\description{
This function converts a raw vector to a 64-bit integer,
handling both signed and unsigned conversions.
}
\examples{
r <- as.raw(c(0x12,0x34,0x56,0x78,0x90,0xAB,0xCD,0xEF))
seasonder_raw_to_int(r, signed=TRUE)
}
End seasonder_raw_to_int.Rd

Start seasonder_readCSField.Rd
\name{seasonder_readCSField}
\alias{seasonder_readCSField}
\title{Read a CSField from a Binary Connection}
\usage{
seasonder_readCSField(con, type, endian = "big")
}
\arguments{
\item{con}{A connection object to a binary file.}

\item{type}{A character string identifying the type of data to read.}

\item{endian}{A character string indicating the byte order. Options are "big" and "little" (default is "big").}
}
\value{
The value read from the connection.
}
\description{
This function reads specific data types from a binary connection,
supporting various types including integer, float, double, complex, and strings.
}
\section{Supported Data Types}{

This function provides support for reading a variety of data types from a binary connection. The following data types are recognized and can be used for the \code{type} argument:

\describe{
\item{\code{CharN}}{Reads N characters from the connection where N is a positive integer. For example, \code{Char5} would read five characters.}

\item{\code{UInt8}}{Reads an 8-bit unsigned integer.}

\item{\code{SInt8}}{Reads an 8-bit signed integer.}

\item{\code{UInt16}}{Reads a 16-bit unsigned integer.}

\item{\code{SInt16}}{Reads a 16-bit signed integer.}

\item{\code{UInt32}}{Reads a 32-bit unsigned integer.}

\item{\code{SInt32}}{Reads a 32-bit signed integer.}

\item{\code{Float}}{Reads a single-precision floating-point number.}

\item{\code{Double}}{Reads a double-precision floating-point number.}

\item{\code{UInt64}}{Reads a 64-bit unsigned integer.}

\item{\code{SInt64}}{Reads a 64-bit signed integer.}

\item{\code{Complex}}{Reads a complex number by separately reading the real and imaginary parts, which are each represented as double-precision floating-point numbers.}

\item{\code{String}}{Reads a null-terminated string.}
}

If the provided \code{type} does not match any of the supported data types, the function raises an error.
}

\section{Error Management}{

This function utilizes the \code{rlang} package to manage errors and provide detailed and structured error messages:

\strong{Error Classes}:
\itemize{
\item \code{seasonder_cs_field_reading_error}: General error related to reading a CSField from the binary connection.
\item \code{seasonder_cs_field_skipped}: Condition that indicates a CSField was skipped due to a reading error.
}

\strong{Error Cases}:
\itemize{
\item Connection is not open.
\item Error while reading value from connection.
\item Read value of length 0 from connection (likely reached end of file).
\item Unrecognized data type specified.
}

\strong{Restart Options}:
This function provides a structured mechanism to recover from errors during its execution using the \code{rlang::withRestarts} function. The following restart option is available:

\describe{
\item{\code{seasonder_skip_cs_field(cond, value)}}{This allows for the graceful handling of reading errors. If this restart is invoked, the function will log an error message indicating that a specific CSField reading was skipped and will return the value specified. The restart takes two arguments: \code{cond} (the condition or error that occurred) and \code{value} (the value to return if this CSField reading is skipped). To invoke this restart during a condition or error, you can use the helper function \code{seasonder_skip_cs_field(cond, value)}.
\itemize{
\item \strong{Usage}: In a custom condition handler, you can call \code{seasonder_skip_cs_field(cond, yourDesiredReturnValue)} to trigger this restart and skip the current CSField reading.
\item \strong{Effect}: If invoked, the function logs an error message detailing the reason for skipping, and then returns the value specified in the restart function call.
}}
}
}

\examples{
\dontrun{
con <- rawConnection(as.raw(c(0x12)))
seasonder_readCSField(con, "UInt8")
}
}
\seealso{
seasonder_raw_to_int For converting raw to 64-bit integers.
}
End seasonder_readCSField.Rd

Start seasonder_readSeaSondeAPMFile.Rd
\name{seasonder_readSeaSondeAPMFile}
\alias{seasonder_readSeaSondeAPMFile}
\title{Read and Parse a SeaSonde APM File}
\usage{
seasonder_readSeaSondeAPMFile(file_path, ...)
}
\arguments{
\item{file_path}{The path to the SeaSonde APM file to read.}

\item{...}{Additional arguments passed to the object creation function (See \code{\link{seasonder_createSeaSondeAPM}} for more details).}
}
\value{
Returns a SeaSondeAPM object containing the parsed data.
}
\description{
This function reads a SeaSonde APM file and returns a SeaSondeAPM object containing
the parsed data.
}
\seealso{
\code{\link{seasonder_createSeaSondeAPM}}

\code{\link{seasonder_validateAttributesSeaSondeAPM}}
}
End seasonder_readSeaSondeAPMFile.Rd

Start seasonder_readSeaSondeCSFileBlock.Rd
\name{seasonder_readSeaSondeCSFileBlock}
\alias{seasonder_readSeaSondeCSFileBlock}
\title{Read and Apply Quality Control to a Block of Fields}
\usage{
seasonder_readSeaSondeCSFileBlock(spec, connection, endian = "big")
}
\arguments{
\item{spec}{A named list of specifications for fields to read. Each specification should be in
the form:
list(type = "data_type", qc_fun = "qc_function_name", qc_params = list(param1 = value1, ...))
Where:
\itemize{
\item \code{type}: is the data type to read, which will be passed to \code{seasonder_readCSField}.
\item \code{qc_fun}: is the name of a quality control function. This function should be present in the
shared environment \code{seasonder_the} and must accept \code{field_value} as its first argument,
followed by any other arguments specified in \code{qc_params}.
\item \code{qc_params}: is a list of additional parameters to pass to the quality control function.
}}

\item{connection}{A connection to the binary file.}

\item{endian}{A character string indicating the byte order. Options are "big" and "little" (default is "big").}
}
\value{
A named list where each entry corresponds to a field that has been read. Each key is
the field name, and its associated value is the data for that field after quality control.
}
\description{
Reads a block of fields from a binary file based on provided specifications. Each field is read
and then processed with a specified quality control function.
}
\details{
The quality control (QC) functions (\code{qc_fun}) specified within \code{spec} play a pivotal role in ensuring the
reliability of the data that's read. Here's the expected behavior of these QC functions:
\itemize{
\item \strong{Input}:
\itemize{
\item \code{field_value}: Value of the field that has been read from the binary file using the \code{seasonder_readCSField} function.
\item \code{...}: Additional parameters specified in \code{qc_params} that are passed to \code{qc_fun} for quality control.
}
\item \strong{Functioning}:
The QC function receives a read value and performs checks or transformations based on defined rules or parameters.
\itemize{
\item \strong{On QC failure}:
\itemize{
\item The QC function itself is responsible for determining the action to take. It can log an error, return a default
value, impute the value, and more.
\item For critical errors, the QC function could halt the execution. However, note that logging is managed by the QC
function and won't necessarily halt execution in every case.
}
\item \strong{On success}:
The QC function will return the value (either unchanged or transformed).
}
\item \strong{Output}:
Value that has been validated or transformed based on quality control rules.
\item \strong{Additional Notes}:
\itemize{
\item The action on QC failure is directly implemented within the QC function.
\item Reading errors are managed by the \code{seasonder_readCSField} function, which returns NULL in the case of an error. It
is up to the QC function to decide what to do if it receives a NULL.
}
}
}
End seasonder_readSeaSondeCSFileBlock.Rd

Start seasonder_readSeaSondeCSFileData.Rd
\name{seasonder_readSeaSondeCSFileData}
\alias{seasonder_readSeaSondeCSFileData}
\title{Read SeaSonde Cross Spectra (CS) File Data}
\usage{
seasonder_readSeaSondeCSFileData(connection, header, endian = "big")
}
\arguments{
\item{connection}{A connection object to the CS file.}

\item{header}{A list containing the header information. This is typically the output
of the \code{seasonder_readSeaSondeCSFileHeader} function.}

\item{endian}{Character string indicating the byte order. Options are "big" (default) or "little".}
}
\value{
A list containing the matrices for \verb{SSA*}, \code{CSxy}, and \code{QC} (when applicable).
}
\description{
This function reads the SeaSonde CS file data based on the provided header information.
The CS file data includes the antenna voltage squared self spectra (\verb{SSA*}) and the
antenna cross spectra (\code{CSxy}). Additionally, a quality matrix (\code{QC}) is read when the header's
\code{nCsKind} is greater than or equal to 2.
}
\details{
\itemize{
\item \verb{SSA*}: Represents the Antenna * voltage squared self spectra. These are matrices
where each row corresponds to a range and each column to a Doppler cell.
\item \code{CSxy}: Represents the cross spectra between two antennas x and y. These are complex matrices.
\item \code{QC}: Quality matrix with values ranging from zero to one. A value less than one indicates
that the SpectraAverager skipped some data during averaging.
}
}
\examples{
\dontrun{
  con <- file("path_to_CS_file", "rb")
  header <- seasonder_readSeaSondeCSFileHeader(specs, con)
  data <- seasonder_readSeaSondeCSFileData(con, header)
  close(con)
}
}
End seasonder_readSeaSondeCSFileData.Rd

Start seasonder_readSeaSondeCSFileHeader.Rd
\name{seasonder_readSeaSondeCSFileHeader}
\alias{seasonder_readSeaSondeCSFileHeader}
\title{Read the SeaSonde CS File Header}
\usage{
seasonder_readSeaSondeCSFileHeader(specs, connection, endian = "big")
}
\arguments{
\item{specs}{List of header specifications for each version.}

\item{connection}{The file connection.}

\item{endian}{Character string indicating the byte order, either "big" (default) or "little".}
}
\value{
A combined list of all processed headers up to the file version.
}
\description{
This function reads and processes the header of a SeaSonde CS file. It initially reads
the general header (Version 1) to determine the file version. Subsequent headers are processed
based on the file version.
}
End seasonder_readSeaSondeCSFileHeader.Rd

Start seasonder_readSeaSondeCSFileHeaderV1.Rd
\name{seasonder_readSeaSondeCSFileHeaderV1}
\alias{seasonder_readSeaSondeCSFileHeaderV1}
\title{Read SeaSonde File Header (Version 1)}
\usage{
seasonder_readSeaSondeCSFileHeaderV1(
  specs,
  connection,
  endian = "big",
  prev_data = NULL
)
}
\arguments{
\item{specs}{A list containing specifications for reading the file.}

\item{connection}{Connection object to the file.}

\item{endian}{Character string specifying the endianness. Default is "big".}
}
\value{
A list with the read and transformed results.
}
\description{
Reads the header of a SeaSonde file (Version 1) based on the provided specifications.
Transforms the date-time fields and returns the results.
}
End seasonder_readSeaSondeCSFileHeaderV1.Rd

Start seasonder_readSeaSondeCSFileHeaderV2.Rd
\name{seasonder_readSeaSondeCSFileHeaderV2}
\alias{seasonder_readSeaSondeCSFileHeaderV2}
\title{Read SeaSonde File Header (Version 2)}
\usage{
seasonder_readSeaSondeCSFileHeaderV2(
  specs,
  connection,
  endian = "big",
  prev_data = NULL
)
}
\arguments{
\item{specs}{A list containing specifications for reading the file.}

\item{connection}{Connection object to the file.}

\item{endian}{Character string specifying the endianness. Default is "big".}
}
\value{
A list with the read results.
}
\description{
Reads the header of a SeaSonde file (Version 2) based on the provided specifications.
}
End seasonder_readSeaSondeCSFileHeaderV2.Rd

Start seasonder_readSeaSondeCSFileHeaderV3.Rd
\name{seasonder_readSeaSondeCSFileHeaderV3}
\alias{seasonder_readSeaSondeCSFileHeaderV3}
\title{Read SeaSonde File Header (Version 3)}
\usage{
seasonder_readSeaSondeCSFileHeaderV3(
  specs,
  connection,
  endian = "big",
  prev_data = NULL
)
}
\arguments{
\item{specs}{A list containing specifications for reading the file.}

\item{connection}{Connection object to the file.}

\item{endian}{Character string specifying the endianness. Default is "big".}
}
\value{
A list with the read results.
}
\description{
Reads the header of a SeaSonde file (Version 3) based on the provided specifications.
Adds nRangeCells, nDopplerCells, and nFirstRangeCell as constant values to the results.
}
End seasonder_readSeaSondeCSFileHeaderV3.Rd

Start seasonder_readSeaSondeCSFileHeaderV4.Rd
\name{seasonder_readSeaSondeCSFileHeaderV4}
\alias{seasonder_readSeaSondeCSFileHeaderV4}
\title{Read SeaSonde File Header (Version 4)}
\usage{
seasonder_readSeaSondeCSFileHeaderV4(
  specs,
  connection,
  endian = "big",
  prev_data = NULL
)
}
\arguments{
\item{specs}{A list containing specifications for reading the file.}

\item{connection}{Connection object to the file.}

\item{endian}{Character string specifying the endianness. Default is "big".}
}
\value{
A list with the read and transformed results.
}
\description{
Reads the header of a SeaSonde file (Version 4) based on the provided specifications.
Transforms the CenterFreq field and returns the results.
}
End seasonder_readSeaSondeCSFileHeaderV4.Rd

Start seasonder_readSeaSondeCSFileHeaderV5.Rd
\name{seasonder_readSeaSondeCSFileHeaderV5}
\alias{seasonder_readSeaSondeCSFileHeaderV5}
\title{Read SeaSonde File Header (Version 5)}
\usage{
seasonder_readSeaSondeCSFileHeaderV5(
  specs,
  connection,
  endian = "big",
  prev_data = NULL
)
}
\arguments{
\item{specs}{A list containing specifications for reading the file.}

\item{connection}{Connection object to the file.}

\item{endian}{Character string specifying the endianness. Default is "big".}
}
\value{
A list with the read and transformed results.
}
\description{
Reads the header of a SeaSonde file (Version 5) based on the provided specifications.
Performs applicable transformations and returns the results.
}
End seasonder_readSeaSondeCSFileHeaderV5.Rd

Start seasonder_readSeaSondeCSFileHeaderV6.Rd
\name{seasonder_readSeaSondeCSFileHeaderV6}
\alias{seasonder_readSeaSondeCSFileHeaderV6}
\title{Read SeaSonde CS File Header V6}
\usage{
seasonder_readSeaSondeCSFileHeaderV6(
  specs,
  connection,
  endian = "big",
  prev_data = NULL
)
}
\arguments{
\item{specs}{A list of specifications for reading the file header. It should contain three main elements:
\code{nCS6ByteSize}, \code{block_spec}, and \code{blocks}, each containing further specifications for reading various parts of the header.}

\item{connection}{A connection object to the SeaSonde CS file.}

\item{endian}{The byte order for reading the file. Default is "big".}

\item{prev_data}{Previous data, if any, that might affect the current reading. Default is NULL.}
}
\value{
A list containing the read data, organized based on the block keys.
}
\description{
This function reads the header of a SeaSonde CS File Version 6.
It sequentially reads blocks based on the provided specifications and returns the read data.
}
End seasonder_readSeaSondeCSFileHeaderV6.Rd

Start seasonder_readYAMLSpecs.Rd
\name{seasonder_readYAMLSpecs}
\alias{seasonder_readYAMLSpecs}
\title{Read Specifications from a YAML File}
\usage{
seasonder_readYAMLSpecs(file_path, path)
}
\arguments{
\item{file_path}{A string. The path to the YAML file.}

\item{path}{A character vector. Represents the path within the YAML file to
access the desired information. For example, to access fields of version V2
of the header, the path would be \code{c("header", "versions", "V2")}.}
}
\value{
A list. The information extracted from the YAML file based on the
provided path.
}
\description{
This function reads a YAML file containing specifications, handles potential
reading errors, and extracts specific information based on a provided path.
}
\section{Error Handling}{

The function has built-in error handling which aborts the function's execution and logs
detailed error messages in case of:
\itemize{
\item File not found.
\item Error in reading the YAML content.
\item If the read YAML content is not of list type.
\item If no data is found for the provided path in the YAML content.
}
Errors generated are of class \code{"seasonder_read_yaml_file_error"}.
Detailed error information including the file path and path within the file
is provided. For logging and aborting, this function utilizes the
\code{\link[=seasonder_logAndAbort]{seasonder_logAndAbort}} function.
}

\examples{
\dontrun{
# Assuming a YAML file named "example.yaml" exists with appropriate content
result <- seasonder_readYAMLSpecs("example.yaml", c("header", "versions", "V2"))
print(result)
}

}
\seealso{
\code{\link[yaml]{read_yaml}} for the underlying YAML reading.

\code{\link[purrr]{pluck}} for the data extraction mechanism used.
}
End seasonder_readYAMLSpecs.Rd

Start seasonder_validateAttributesSeaSondeAPM.Rd
\name{seasonder_validateAttributesSeaSondeAPM}
\alias{seasonder_validateAttributesSeaSondeAPM}
\title{Validate Attributes for a SeaSondeAPM Object}
\usage{
seasonder_validateAttributesSeaSondeAPM(seasonde_apm_obj)
}
\arguments{
\item{seasonde_apm_obj}{A SeaSondeAPM object whose attributes are to be validated.}
}
\value{
TRUE if all attributes are valid. The function will stop execution and display an error message if any of the attributes are invalid.
}
\description{
This function validates the attributes of a given SeaSondeAPM object to ensure they meet the required specifications.
}
\details{
The function performs validation on the following attributes of the SeaSondeAPM object:
\itemize{
\item quality_matrix
\item BEAR
\item Type
\item Creator
\item SiteName
\item SiteOrigin
\item FileName
\item CreateTimeStamp
\item ProcessingSteps
\item AmplitudeFactors
\item AntennaBearing
\item StationCode
\item BearingResolution
\item Smoothing
\item CommentLine
\item FileID
\item PhaseCorrections
}

It internally calls specific validation functions for each of these attributes. If any of the attributes are found to be invalid, the function will stop execution and display an error message.

For more details on the attributes, see \code{\link{seasonder_initializeAttributesSeaSondeAPM}}.
}
\examples{
# Create a mock SeaSondeAPM object with valid attributes
mock_matrix <- matrix(complex(real = c(1, 2), imaginary = c(3, 4)), nrow = 2)
mock_apm <- seasonder_createSeaSondeAPM(mock_matrix)

# Validate attributes
valid <- seasonder_validateAttributesSeaSondeAPM(mock_apm)
print(valid)  # Should print TRUE if all attributes are valid

}
\seealso{
\code{\link{validate_SeaSondeAPM_quality_matrix}},
\code{\link{validate_SeaSondeAPM_BEAR}},
\code{\link{validate_SeaSondeAPM_Type}},
\code{\link{validate_SeaSondeAPM_Creator}},
\code{\link{validate_SeaSondeAPM_SiteName}},
\code{\link{validate_SeaSondeAPM_SiteOrigin}},
\code{\link{validate_SeaSondeAPM_FileName}},
\code{\link{validate_SeaSondeAPM_CreateTimeStamp}},
\code{\link{validate_SeaSondeAPM_ProcessingSteps}},
\code{\link{validate_SeaSondeAPM_AmplitudeFactors}},
\code{\link{validate_SeaSondeAPM_AntennaBearing}},
\code{\link{validate_SeaSondeAPM_StationCode}},
\code{\link{validate_SeaSondeAPM_BearingResolution}},
\code{\link{validate_SeaSondeAPM_Smoothing}},
\code{\link{validate_SeaSondeAPM_CommentLine}},
\code{\link{validate_SeaSondeAPM_FileID}},
\code{\link{validate_SeaSondeAPM_PhaseCorrections}}
}
End seasonder_validateAttributesSeaSondeAPM.Rd

Start seasonder_validateCalibrationMatrixSeaSondeAPM.Rd
\name{seasonder_validateCalibrationMatrixSeaSondeAPM}
\alias{seasonder_validateCalibrationMatrixSeaSondeAPM}
\title{Validate Calibration Matrix for a SeaSondeAPM Object}
\usage{
seasonder_validateCalibrationMatrixSeaSondeAPM(matrix)
}
\arguments{
\item{matrix}{A 2 x b complex matrix for calibration, where b is the number of bearings.}
}
\value{
TRUE if the matrix is valid. The function will stop execution and display an error message if the matrix is invalid.
}
\description{
This function validates the input calibration_matrix to ensure it meets the required specifications
for use in a SeaSondeAPM object.
}
\details{
The function performs the following validation checks:
\enumerate{
\item Confirms that the input is a matrix.
\item Verifies that the matrix has exactly two rows.
\item Checks that the matrix contains only complex numbers.
}

If any of these validation steps fail, the function will log a fatal error and stop the execution using \code{rlang::abort}.
}
\examples{
# Invalid matrix: not a matrix
invalid_matrix1 <- c(1, 2)
# This will cause an error
# seasonder_validateCalibrationMatrixSeaSondeAPM(invalid_matrix1)

# Invalid matrix: not two rows
invalid_matrix2 <- matrix(complex(real = c(1, 2, 3), imaginary = c(4, 5, 6)), nrow = 3)
# This will cause an error
# seasonder_validateCalibrationMatrixSeaSondeAPM(invalid_matrix2)

# Valid matrix
valid_matrix <- matrix(complex(real = c(1, 2), imaginary = c(3, 4)), nrow = 2)
seasonder_validateCalibrationMatrixSeaSondeAPM(valid_matrix)  # No error

}
\seealso{
\code{\link{seasonder_createSeaSondeAPM}}
}
End seasonder_validateCalibrationMatrixSeaSondeAPM.Rd

Start validate_SeaSondeAPM_AmplitudeFactors.Rd
\name{validate_SeaSondeAPM_AmplitudeFactors}
\alias{validate_SeaSondeAPM_AmplitudeFactors}
\title{Validate AmplitudeFactors Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_AmplitudeFactors(factors)
}
\arguments{
\item{factors}{The numeric vector to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided AmplitudeFactors is a numeric vector of length 2.
}
End validate_SeaSondeAPM_AmplitudeFactors.Rd

Start validate_SeaSondeAPM_AntennaBearing.Rd
\name{validate_SeaSondeAPM_AntennaBearing}
\alias{validate_SeaSondeAPM_AntennaBearing}
\title{Validate AntennaBearing Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_AntennaBearing(bearing)
}
\arguments{
\item{bearing}{The numeric value to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided AntennaBearing is a numeric value.
}
End validate_SeaSondeAPM_AntennaBearing.Rd

Start validate_SeaSondeAPM_BEAR.Rd
\name{validate_SeaSondeAPM_BEAR}
\alias{validate_SeaSondeAPM_BEAR}
\title{Validate BEAR Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_BEAR(vector, seasonde_apm_obj)
}
\arguments{
\item{vector}{The numeric vector to be validated.}

\item{seasonde_apm_obj}{The SeaSondeAPM object for compatibility check.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided BEAR is a numeric vector and if its length
matches the number of columns in the calibration_matrix of the given SeaSondeAPM object.
It also validates that the bearings are between -180 and 180 degrees.
}
End validate_SeaSondeAPM_BEAR.Rd

Start validate_SeaSondeAPM_BearingResolution.Rd
\name{validate_SeaSondeAPM_BearingResolution}
\alias{validate_SeaSondeAPM_BearingResolution}
\title{Validate BearingResolution Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_BearingResolution(resolution)
}
\arguments{
\item{resolution}{The numeric value to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided BearingResolution is a numeric value.
}
End validate_SeaSondeAPM_BearingResolution.Rd

Start validate_SeaSondeAPM_CommentLine.Rd
\name{validate_SeaSondeAPM_CommentLine}
\alias{validate_SeaSondeAPM_CommentLine}
\title{Validate CommentLine Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_CommentLine(comment)
}
\arguments{
\item{comment}{The character string to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided CommentLine is a character string.
}
End validate_SeaSondeAPM_CommentLine.Rd

Start validate_SeaSondeAPM_CreateTimeStamp.Rd
\name{validate_SeaSondeAPM_CreateTimeStamp}
\alias{validate_SeaSondeAPM_CreateTimeStamp}
\title{Validate CreateTimeStamp Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_CreateTimeStamp(timestamp)
}
\arguments{
\item{timestamp}{The Date object to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided CreateTimeStamp is a POSIXct Date object.
}
End validate_SeaSondeAPM_CreateTimeStamp.Rd

Start validate_SeaSondeAPM_Creator.Rd
\name{validate_SeaSondeAPM_Creator}
\alias{validate_SeaSondeAPM_Creator}
\title{Validate Creator Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_Creator(creator)
}
\arguments{
\item{creator}{The character string to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided Creator is a character string.
}
End validate_SeaSondeAPM_Creator.Rd

Start validate_SeaSondeAPM_FileID.Rd
\name{validate_SeaSondeAPM_FileID}
\alias{validate_SeaSondeAPM_FileID}
\title{Validate FileID Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_FileID(id)
}
\arguments{
\item{id}{The unique character string to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided FileID is a unique character string.
}
End validate_SeaSondeAPM_FileID.Rd

Start validate_SeaSondeAPM_FileName.Rd
\name{validate_SeaSondeAPM_FileName}
\alias{validate_SeaSondeAPM_FileName}
\title{Validate FileName Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_FileName(file_name)
}
\arguments{
\item{file_name}{The character string to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided FileName is a character string.
}
End validate_SeaSondeAPM_FileName.Rd

Start validate_SeaSondeAPM_PhaseCorrections.Rd
\name{validate_SeaSondeAPM_PhaseCorrections}
\alias{validate_SeaSondeAPM_PhaseCorrections}
\title{Validate PhaseCorrections Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_PhaseCorrections(corrections)
}
\arguments{
\item{corrections}{The numeric vector to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided PhaseCorrections attribute is a numeric
vector of length 2.
}
End validate_SeaSondeAPM_PhaseCorrections.Rd

Start validate_SeaSondeAPM_ProcessingSteps.Rd
\name{validate_SeaSondeAPM_ProcessingSteps}
\alias{validate_SeaSondeAPM_ProcessingSteps}
\title{Validate ProcessingSteps Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_ProcessingSteps(steps)
}
\arguments{
\item{steps}{The character vector to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided ProcessingSteps is a character vector.
}
End validate_SeaSondeAPM_ProcessingSteps.Rd

Start validate_SeaSondeAPM_quality_matrix.Rd
\name{validate_SeaSondeAPM_quality_matrix}
\alias{validate_SeaSondeAPM_quality_matrix}
\title{Validate quality_matrix Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_quality_matrix(matrix, seasonde_apm_obj)
}
\arguments{
\item{matrix}{The matrix to be validated.}

\item{seasonde_apm_obj}{The SeaSondeAPM object for compatibility check.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided quality_matrix is a 2-row complex matrix.
It also checks if the number of columns matches that of the calibration_matrix in the given SeaSondeAPM object.
}
End validate_SeaSondeAPM_quality_matrix.Rd

Start validate_SeaSondeAPM_SiteName.Rd
\name{validate_SeaSondeAPM_SiteName}
\alias{validate_SeaSondeAPM_SiteName}
\title{Validate SiteName Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_SiteName(site_name)
}
\arguments{
\item{site_name}{The character string to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided SiteName is a character string.
}
End validate_SeaSondeAPM_SiteName.Rd

Start validate_SeaSondeAPM_SiteOrigin.Rd
\name{validate_SeaSondeAPM_SiteOrigin}
\alias{validate_SeaSondeAPM_SiteOrigin}
\title{Validate SiteOrigin Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_SiteOrigin(site_origin)
}
\arguments{
\item{site_origin}{The numeric vector to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided SiteOrigin is a numeric vector of length 2.
}
End validate_SeaSondeAPM_SiteOrigin.Rd

Start validate_SeaSondeAPM_Smoothing.Rd
\name{validate_SeaSondeAPM_Smoothing}
\alias{validate_SeaSondeAPM_Smoothing}
\title{Validate Smoothing Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_Smoothing(smoothing)
}
\arguments{
\item{smoothing}{The numeric value to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided Smoothing is a numeric value.
}
End validate_SeaSondeAPM_Smoothing.Rd

Start validate_SeaSondeAPM_StationCode.Rd
\name{validate_SeaSondeAPM_StationCode}
\alias{validate_SeaSondeAPM_StationCode}
\title{Validate StationCode Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_StationCode(code)
}
\arguments{
\item{code}{The character string to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided StationCode is an empty character string or a 4-character string of length 1.
}
End validate_SeaSondeAPM_StationCode.Rd

Start validate_SeaSondeAPM_Type.Rd
\name{validate_SeaSondeAPM_Type}
\alias{validate_SeaSondeAPM_Type}
\title{Validate Type Attribute for a SeaSondeAPM Object}
\usage{
validate_SeaSondeAPM_Type(type)
}
\arguments{
\item{type}{The character string to be validated.}
}
\value{
Returns TRUE if the validation passes.
}
\description{
This function validates if the provided Type is a character string.
}
End validate_SeaSondeAPM_Type.Rd

